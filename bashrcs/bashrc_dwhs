# $HOME/.bashrcs/bashrc_dwhs

PS1="${UNISONLOCALHOSTNAME}:\w \u$ "
PROMPT_COMMAND='echo -ne "\033]0;${USER}@${UNISONLOCALHOSTNAME}: ${PWD}\007"'

# This next thing is to convince bash to show the currently running process
# in the window title. This can be extremely useful when you have a lot of
# tabs open: lets you quickly check what is running in each tab.
# stolen wholesale from: http://mg.pov.lt/blog/bash-prompt.html
#case "$TERM" in
#xterm*|rxvt*)
    ## Show the currently running command in the terminal title:
    ## http://www.davidpashley.com/articles/xterm-titles-with-bash.html
    #show_command_in_title_bar()
    #{
        #case "$BASH_COMMAND" in
            #*\033]0*)
                ## The command is trying to set the title bar as well;
                ## this is most likely the execution of $PROMPT_COMMAND.
                ## In any case nested escapes confuse the terminal, so don't
                ## output them.
                #;;
            #*)
                #DEFAULT_TITLE="${USER}@${UNISONLOCALHOSTNAME}: ${PWD}"
                #mycmd=`echo $BASH_COMMAND | awk '{ print $1 }'`
                ## these are the programs I commonly use, and how I want them
                ## to be visualized
                #case "$mycmd" in
                    #vi)     mycmd="VIM" ;;
                    #vim)    mycmd="VIM" ;;
                    #less)   mycmd="LESS" ;;
                    #sftp)   mycmd="SFTP" ;;
                    #*)      mycmd=`echo $mycmd | sed 's/.*\///'` ;;
                #esac

                #echo -ne "\033]0;(${mycmd}) ${DEFAULT_TITLE}\007"
                #;;
        #esac
    #}
    
    #trap show_command_in_title_bar DEBUG
    #;;
#*)
    #;;
#esac

# ls has different color behavior on different system; on most systems I
# want to use the -G option. If it is different for a specific computer, I
# set LS_COLOR_OPT in that computer's bashrc
if [ -z "$LS_COLOR_OPT" ]
then
  # what it normally is !!
  export LS_COLOR_OPT="-G"
fi
export LSCOLORS="ExexdxhxCxegedBxbxeAeA"
export CLICOLOR=1
alias ls="ls -F ${LS_COLOR_OPT}" 
# tho I *do* say ls is for wimps... "echo *" baby!


# tell bash to use vi bindings (really, I should edit .inputrc so that
# everything that uses readline will recognize this preference)
set -o vi

# an extra s to ignore keys
alias sssh="ssh -o 'PubkeyAuthentication=no'"

# how I think a few commands SHOULD work by default
alias rm="rm -i"
alias ps="ps -o user,pid,tty,%cpu,%mem,nice,state,time,command"
alias more="less" # more is less (and less is more?)
alias scp="scp -r"
alias reduce="reduce -w"

#a few of my favorite typos/shortcuts
alias ls-l="ls -F -l"
alias cd..="cd .."
alias lo="exit"     # 'lo' as in 'logout'. You have no idea how nice this is
alias pingg="ping google.com"  # regularly used in checking connectivity
# cloc is a script to Count Lines Of Code (in my ~/.scripts/ directory) 
# somebody else wrote it, but I use it to gauge how much coding I've done
alias cloc="cloc-1.66.pl --no3 --exclude-dir=.svn --not-match-f=y.tab.. --not-match-f=lex.yy.c --exclude_dir docs"
# I don't use Midnight Commander, but kept accidentally launching it when I
# typed "mc" instead of "mv"
alias mcmc="/usr/bin/mc" # we assume that's where it is kept
alias mc="echo 'Midnight Commander has been moved to mcmc, after too many mv typos'"
alias pyclewn='pyclewn -c "-c \"call Pyclewnmappings()\"" '

# a joke I play on myself when I try for ls, but my finger slips after the s
#  -- sadly, this only makes sense right now for lsd -1; lsd -l is awful
function lsd
{
    for file in `ls $@`
    do
        echo "$(tput setaf $((${RANDOM} % 7 + 1)) )$file"
    done 
    echo "$(tput sgr0)If the doors of perception were cleansed, everything would appear to man as it "
    echo "is, infinite.................................................................."
}

alias remake="make clean && make"
# if you run code in a versioned directory that generates a bunch of
# unversioned files, and all you want to know is which files you've
# changed...
alias svnchanged='svn stat | grep "^M"'

# labeling directories by date is fun: mkdir `today`; cd `today`; etc
alias today="date +%Y%m%d"
alias yesterday="date -v -1d +%Y%m%d"
# at some point, turn this into a function such that we can call:
#  `today`   `today -1`  `today -1m` .... etc
alias nextmon="date -v+1d -v+Mon +%Y%m%d" # weekly Monday meetings

alias ipynb="jupyter notebook"


# everybody's got an mkcd function, right? There are probably better
# implementations out there
function mkcd
{
    mkdir "$@" && cd $_
}

# when you need to remove more than MAXFILES files ....
function rrmf
{
# TODO: put in some checking here to prevent it from running if it removes
# more than all the files in the directory; warning of how many files it'll
# remove, etc
    for file in $@ 
    do 
      rm -f $file
    done
}

# for a while I used a URL-schema called cdvi to cd to a directory and then
# vi a file. This parses the URL, or can be used as a non-URL command
function cdvi
{
    cleaned=`echo $@ | sed 's/cdvi:\/\///'`
    basedir=`echo $cleaned | sed 's/\(.*\)\/\(.*\)/\1/'`
    fname=`echo $cleaned | sed 's/\(.*\)\/\(.*\)/\2/'`
    cd $basedir
    vi $fname
}

# generates cdvi URLs for files given as arguments. Assumes existence of
# said files.
function cdvi-gen
{
    for file in $@
    do
      echo "cdvi://${PWD}/$file"
    done
}

function mydynamiq
{
    BASEDIR_SAFE=`echo $DYNAMIQ_BASEDIR | sed 's:\/:\\\/:g'`
    BRANCH=`pwd -P | sed "s/$BASEDIR_SAFE\/\(branches\/[^\/]*\/[^\/]*\).*/\1/"`
    echo "${DYNAMIQ_BASEDIR}/${BRANCH}/dynamiq"
}

function swapnames
{
    tmpfile=$1_$2
    if [ -e $tmpfile ]
    then
      echo "Error: tmpfile $tmpfile couldn't be created"
    else
      mv $1 $tmpfile
      mv $2 $1
      mv $tmpfile $2
      rm -f $tmpfile
    fi
}

# you know you've spent too much time in VMS when...
alias edit="vi"
alias copy="cp"

# random places we hide programs
export PATH=$PATH:/usr/local/bin:$HOME/bin
# my own inventions hide here:
export PATH=$PATH:/usr/local/scripts/:~/.scripts:$HOME/bin

export GNUPLOT_LIB=$GNUPLOT_LIB:~/.gnuplotd
# officially set up for gdb, but might be useful elsewhere:
export EDITOR=vim

if [ $SHELL = "bash" ]
then
  source ~/.scripts/git-completion.bash
fi
